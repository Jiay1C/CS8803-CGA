/////////////////////////////////////////////////////
//// CS 8803/4803 CGAI: Computer Graphics in AI Era
//// Assignment 1B: Neural SDF
/////////////////////////////////////////////////////

precision highp float;              //// set default precision of float variables to high precision

varying vec2 vUv;                   //// screen uv coordinates (varying, from vertex shader)
uniform vec2 iResolution;           //// screen resolution (uniform, from CPU)
uniform float iTime;                //// time elapsed (uniform, from CPU)

#define USE_CUSTOM_MODEL

#define ROTATION_SPEED 1.0

#define MAX_RAYMARCHING_ITER 100
#define MIN_RAYMARCHING_DISTANCE 0.001

#define PI 3.1415925359

#ifdef USE_CUSTOM_MODEL
#define BACKGROUD_COLOR vec3(0.2, 0.2, 0.2)
#else
#define BACKGROUD_COLOR vec3(0.04, 0.16, 0.33)
#endif

const vec3 CAM_POS = vec3(0, 1, 0);

vec3 rotate(vec3 p, vec3 ax, float ro)
{
    return mix(dot(p, ax) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);
}

/////////////////////////////////////////////////////
//// sdf functions
/////////////////////////////////////////////////////

float sdfPlane(vec3 p, float h)
{
    return p.y - h;
}

float sdfBunny(vec3 p, vec3 offset)
{
    p -= offset;
    p = rotate(p, vec3(1., 0., 0.), PI / 2.);
    p = rotate(p, vec3(0., 0., 1.), PI / 2. + PI / 1.);

    // sdf is undefined outside the unit sphere, uncomment to witness the abominations
    if(length(p) > 1.0)
    {
        return length(p) - 0.9;
    }

    //// neural network weights for the bunny 

    vec4 f0_0=sin(p.y*vec4(1.74,-2.67,1.91,-1.93)+p.z*vec4(2.15,-3.05,.50,-1.32)+p.x*vec4(2.47,.30,-2.00,-2.75)+vec4(1.31,6.89,-8.25,.15));
    vec4 f0_1=sin(p.y*vec4(-.72,-3.13,4.36,-3.50)+p.z*vec4(3.39,3.58,-4.52,-1.10)+p.x*vec4(-1.02,-2.90,2.23,-.62)+vec4(1.61,-.84,-2.00,-.47));
    vec4 f0_2=sin(p.y*vec4(-1.47,.32,-.70,-1.51)+p.z*vec4(.17,.75,3.59,4.05)+p.x*vec4(-3.10,1.40,4.72,2.90)+vec4(-6.76,-6.43,2.41,-.66));
    vec4 f0_3=sin(p.y*vec4(-2.75,1.59,3.43,-3.39)+p.z*vec4(4.09,4.09,-2.34,1.23)+p.x*vec4(1.07,.65,-.18,-3.46)+vec4(-5.09,.73,3.06,3.35));
    vec4 f1_0=sin(mat4(.47,.12,-.23,-.04,.48,.06,-.24,.19,.12,.72,-.08,.39,.37,-.14,-.01,.06)*f0_0+
        mat4(-.62,-.40,-.81,-.30,-.34,.08,.26,.37,-.16,.38,-.09,.36,.02,-.50,.34,-.38)*f0_1+
        mat4(-.26,-.51,-.32,.32,-.67,.35,-.43,.93,.12,.34,.07,-.01,.67,.27,.43,-.02)*f0_2+
        mat4(.02,-.18,-.15,-.10,.47,-.07,.82,-.46,.18,.44,.39,-.94,-.20,-.28,-.20,.29)*f0_3+
        vec4(-.09,-3.49,2.17,-1.45))/1.0+f0_0;
    vec4 f1_1=sin(mat4(-.46,-.33,-.85,-.57,.41,.87,.25,.58,-.47,.16,-.14,-.06,-.70,-.82,-.20,.47)*f0_0+
        mat4(-.15,-.73,-.46,-.58,-.54,-.34,-.02,.12,.55,.32,.22,-.87,-.57,-.28,-.51,.10)*f0_1+
        mat4(.75,1.06,-.08,-.17,-.43,.69,1.07,.23,.46,-.02,.10,-.11,.21,-.70,-.08,-.48)*f0_2+
        mat4(.04,-.09,-.51,-.06,1.12,-.21,-.35,-.17,-.95,.49,.22,.99,.62,-.25,.06,-.20)*f0_3+
        vec4(-.61,2.91,-.17,.71))/1.0+f0_1;
    vec4 f1_2=sin(mat4(.01,-.86,-.07,.46,.73,-.28,.83,.12,.16,.33,.28,-.55,-.21,-.02,.53,-.15)*f0_0+
        mat4(-.28,-.32,.19,-.28,.24,-.23,-.61,-.39,.26,.40,.18,.41,.21,.57,-.91,-.29)*f0_1+
        mat4(.23,-.40,-1.34,-.50,.08,-.04,-1.67,-.16,-.65,-.09,.38,-.22,-.14,-.34,.37,.05)*f0_2+
        mat4(-.47,-.23,-.57,-.05,.51,.04,.00,.27,.80,.29,-.09,-.53,-.20,-.41,-.64,-.12)*f0_3+
        vec4(1.08,4.00,-2.54,2.18))/1.0+f0_2;
    vec4 f1_3=sin(mat4(-.30,.38,.39,.53,.73,.73,-.06,.01,.54,-.07,-.19,.68,.59,.40,.04,.07)*f0_0+
        mat4(-.17,.44,-.61,.43,-.84,-.12,.65,-.50,.33,-.31,-.28,.13,.18,-.42,.14,.08)*f0_1+
        mat4(-.78,.06,-.18,.37,-.99,.49,.71,.15,.27,-.48,-.17,.25,.05,.10,-.40,-.21)*f0_2+
        mat4(-.17,-.27,.40,.18,-.24,.23,.03,-.83,-.30,-.38,.07,.21,-.45,-.24,.78,.50)*f0_3+
        vec4(2.14,-3.48,3.81,-1.43))/1.0+f0_3;
    vec4 f2_0=sin(mat4(.83,.15,-.49,-.80,-.83,.16,1.24,.75,-.27,.18,-.13,1.05,.70,-.15,.30,.79)*f1_0+
        mat4(-.38,-.17,.34,.67,-.39,.09,.48,-.93,.19,.60,-.20,-.22,-.76,-.62,-.40,.01)*f1_1+
        mat4(.10,.22,.08,.13,-.42,-.11,.71,-.63,.02,.46,-.07,-.46,-.37,.07,.15,.14)*f1_2+
        mat4(.09,-.48,-.38,.40,-.57,-.88,-.14,-.25,.20,.95,.86,-1.08,.46,.04,.53,-.82)*f1_3+
        vec4(3.47,-3.66,3.06,.84))/1.4+f1_0;
    vec4 f2_1=sin(mat4(1.03,.03,-.76,-.03,.84,.66,-.49,.74,-.09,-.85,-.55,.17,.07,.85,-.55,-.20)*f1_0+
        mat4(-.55,1.13,.41,-.21,-.55,.19,.49,.67,.40,1.80,-.82,-.83,-1.02,.78,-.42,-.51)*f1_1+
        mat4(.77,-.88,.64,1.10,-.49,1.05,-.43,-.38,.66,-.63,.02,.11,-.24,-.23,.49,-.65)*f1_2+
        mat4(-.66,1.90,.02,-.48,.22,-.62,-.68,-.44,.52,-.57,.16,-.61,-.03,-.02,-.88,-.23)*f1_3+
        vec4(.58,-3.00,-2.53,.14))/1.4+f1_1;
    vec4 f2_2=sin(mat4(-.44,-.06,.30,-.37,.27,-.23,-.56,.15,.03,-.14,-.08,.72,.76,-.58,.55,.29)*f1_0+
        mat4(.31,.23,.42,-.17,.37,-.05,.39,.46,-1.14,.32,.06,-.28,.28,-.21,-.58,.62)*f1_1+
        mat4(.92,-.16,.86,-.09,-.12,.33,-.49,-.24,.29,-.19,.95,-.40,-.87,.08,.08,-.71)*f1_2+
        mat4(-.45,.67,1.07,-.14,-.56,.06,-.81,-.15,-.57,-.24,-1.09,.69,-.44,-.32,-.00,-.07)*f1_3+
        vec4(-4.43,-1.86,-2.87,1.45))/1.4+f1_2;
    vec4 f2_3=sin(mat4(.58,.25,.01,-.54,.34,.56,.61,-.79,-.01,.05,-.57,-1.31,.74,.78,-.10,-.11)*f1_0+
        mat4(-.03,-.48,-.24,.01,.10,.23,.22,-.05,.76,.29,-.37,.02,.54,-.07,.27,.38)*f1_1+
        mat4(.31,-1.03,.24,.95,.80,.29,.43,.61,-.04,-.22,-.06,-.52,-.46,.35,.07,-.07)*f1_2+
        mat4(.47,-.12,-.62,.06,.47,-.41,.53,-2.14,-.59,.16,.74,-.58,.32,.66,-.30,-.18)*f1_3+
        vec4(-2.86,-3.27,-.55,2.87))/1.4+f1_3;
    return dot(f2_0,vec4(-.08,.03,.07,-.03))+
        dot(f2_1,vec4(-.03,-.02,-.06,-.07))+
        dot(f2_2,vec4(.05,-.09,.03,.11))+
        dot(f2_3,vec4(.03,.06,-.06,-.03))+
        -0.014;
}

/////////////////////////////////////////////////////
//// Step 1: training a neural SDF model
//// You are asked to train your own neural SDF model on Colab. 
//// Your implementation should take place in neural_sdf.ipynb.
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 2: copy neural SDF weights to GLSL
//// In this step, you are asked to the network weights you have trained from the text file to the function sdfCow().
//// You should replace the default implementation (a sphere) with your own network weights. 
/////////////////////////////////////////////////////

float sdfCow(vec3 p, vec3 offset)
{
    p -= offset;
    p = rotate(p, vec3(1., 0., 0.), PI / 2.);
    p = rotate(p, vec3(0., 0., 1.), PI/3.0 + PI/3.0);

    // sdf is undefined outside the unit sphere, uncomment to witness the abominations
    if(length(p) > 1.)
    {
        return length(p) - 0.9;
    }

    //// your implementation starts

    vec4 f0_0=sin(p.y*vec4(-.62,-1.88,-4.48,2.80)+p.z*vec4(3.13,-4.22,-1.07,-2.99)+p.x*vec4(-1.89,3.14,1.64,-.28)+vec4(3.19,-.31,6.39,2.80));
    vec4 f0_1=sin(p.y*vec4(-4.10,-1.45,1.77,1.69)+p.z*vec4(-4.73,1.28,-2.07,3.30)+p.x*vec4(2.55,1.73,-3.73,4.05)+vec4(8.06,-6.20,.58,-5.95));
    vec4 f0_2=sin(p.y*vec4(-2.49,-3.30,1.02,-.29)+p.z*vec4(-1.14,-1.14,3.33,2.44)+p.x*vec4(3.77,.58,.26,-2.43)+vec4(1.01,-8.36,4.24,-4.98));
    vec4 f0_3=sin(p.y*vec4(-3.04,3.29,.41,.81)+p.z*vec4(4.42,-1.19,-.70,1.32)+p.x*vec4(-4.45,.34,-1.39,-1.42)+vec4(2.59,7.37,-8.26,4.32));
    vec4 f1_0=sin(mat4(-.14,.42,-.45,.24,.33,-.06,-.25,.33,.05,.44,.17,-.32,-.12,.62,-.28,-.26)*f0_0+
    mat4(.30,-.25,.15,.56,.84,-1.18,-.87,-.62,.31,-.14,.33,-.50,-.09,-.32,-.07,-.58)*f0_1+
    mat4(.40,-.06,.18,-.19,.66,.06,-.04,.43,-.40,-.39,.37,.12,-.16,-.41,.10,-.68)*f0_2+
    mat4(-.44,.23,-.22,-.15,-.15,.01,.54,.42,-.17,-.84,-.56,.71,-.05,-.22,-.33,-.95)*f0_3+
    vec4(3.05,.18,-3.37,3.69))/1.0+f0_0;
    vec4 f1_1=sin(mat4(-.26,-.49,-.59,-.59,-.72,-.26,-.09,.36,.82,.27,-.09,.19,-.44,.19,-.15,.23)*f0_0+
    mat4(-.56,.27,.02,.88,-.93,-.09,-.23,-.83,-.23,.28,-.30,-.12,.67,.24,-.48,.56)*f0_1+
    mat4(.09,-.46,.07,-.36,-.10,.33,-1.66,.34,.62,-.35,-.08,-.43,-.44,-.25,.28,.05)*f0_2+
    mat4(-.09,.04,-.19,.42,-.54,.32,-.98,-.18,.15,.55,.97,-.35,-.08,.21,-.39,.15)*f0_3+
    vec4(1.70,-.83,1.23,-3.46))/1.0+f0_1;
    vec4 f1_2=sin(mat4(-.11,-.69,-.59,-.14,-.42,-.06,-.14,-.57,.17,.34,.09,-.27,-.21,.07,.51,-.02)*f0_0+
    mat4(.30,-.24,-.71,-.28,.41,.41,-.62,.03,.02,.30,-.29,-.62,.74,.30,-.37,-.42)*f0_1+
    mat4(-.18,-.04,.17,-.30,.51,-.17,.38,-.27,.47,.25,-.01,-.72,-1.09,-.90,-.47,.33)*f0_2+
    mat4(-.18,.11,-.29,.08,-.31,.34,-.14,-.44,.04,-.70,.36,-.08,-.10,-.26,.04,.46)*f0_3+
    vec4(-2.37,1.16,.79,1.78))/1.0+f0_2;
    vec4 f1_3=sin(mat4(.89,-.66,-.33,.45,-.50,-.38,-.20,.01,-.06,-.04,-.26,.17,-.48,.40,.51,-.32)*f0_0+
    mat4(.64,-.20,-.14,.23,.12,-1.02,-.87,-.08,.44,-.47,-.12,-.21,-.46,.45,-.20,-.13)*f0_1+
    mat4(.43,.00,.10,-.27,.24,-.52,.49,.06,.10,.58,-.62,.32,1.35,.13,.43,-.55)*f0_2+
    mat4(-.07,.04,-.52,-.24,.02,-.02,.34,-.10,.70,-.23,.46,.78,.15,.08,.43,.68)*f0_3+
    vec4(.39,2.25,-1.22,-1.66))/1.0+f0_3;
    vec4 f2_0=sin(mat4(.09,.66,.98,1.06,-.41,.80,.75,.42,.59,.40,-.58,.52,.27,-.86,-.48,-.98)*f1_0+
    mat4(-.45,.83,.81,-.21,.85,1.28,-.56,.98,.56,.44,-.38,-.28,-.18,-.57,.18,-.25)*f1_1+
    mat4(-.33,-.19,.22,.15,.15,-1.19,-.55,1.01,-.41,.61,.82,-.20,-.31,.26,-.20,.48)*f1_2+
    mat4(-.17,-.53,-.22,-.12,.76,-.02,.08,.39,-.44,-.41,-.09,-.99,-.38,.58,-.47,.22)*f1_3+
    vec4(1.10,1.06,2.47,-2.90))/1.4+f1_0;
    vec4 f2_1=sin(mat4(-1.18,-.16,-.63,-.81,-.00,-.45,-.50,-.91,.41,.55,.24,.66,.19,-.66,-.08,-.47)*f1_0+
    mat4(-.56,.46,-.52,1.01,.21,-.52,-.00,-.45,.58,-.12,.35,.10,.65,.10,-.32,-.57)*f1_1+
    mat4(-.51,.24,.02,-.29,.67,-.61,-.39,-.47,-.37,-.22,-1.06,.05,.27,-.27,-.75,.36)*f1_2+
    mat4(.82,.17,.25,-.23,-.07,-1.07,.59,.60,.83,.50,.42,.56,.29,.87,.61,.78)*f1_3+
    vec4(1.29,-3.61,3.17,-.25))/1.4+f1_1;
    vec4 f2_2=sin(mat4(-.45,.25,-.25,-.25,.07,.30,-.25,.35,.16,-.96,-.08,1.09,.09,-.17,.11,.57)*f1_0+
    mat4(-.06,-.39,.41,.55,.51,-.36,.30,.28,-.19,-.45,.71,-.25,-.41,-.23,-.82,.98)*f1_1+
    mat4(.18,-.45,-.11,.29,-1.15,-1.12,.10,.74,-.28,-.25,.64,.35,-.09,.52,.16,-.28)*f1_2+
    mat4(-.44,-.31,-.14,.30,.19,.12,-.11,.33,-.67,-.58,-.73,.01,.40,.16,-.09,-.75)*f1_3+
    vec4(-.06,-3.38,-2.75,1.26))/1.4+f1_2;
    vec4 f2_3=sin(mat4(.70,.26,.99,.65,-.45,.69,.25,-.09,.00,-.26,-.32,.67,-.82,-.47,.78,-.41)*f1_0+
    mat4(-.90,.16,-.23,.01,-1.09,.42,-.01,-.77,-.03,-.41,.15,-.74,-.49,-.80,-.16,-.03)*f1_1+
    mat4(.15,-.15,.60,.33,.31,-.35,.68,-.05,.03,.08,-.27,.46,.80,1.21,-.88,.47)*f1_2+
    mat4(.02,-.58,-.32,-.43,-.15,-.32,-1.00,.21,-1.27,-.95,-.57,.02,.10,.98,-1.31,.16)*f1_3+
    vec4(1.51,4.15,.87,4.02))/1.4+f1_3;
    return dot(f2_0,vec4(-.08,-.05,.05,-.04))+
    dot(f2_1,vec4(-.04,.04,.03,-.03))+
    dot(f2_2,vec4(-.06,.10,.05,.05))+
    dot(f2_3,vec4(.04,-.08,-.05,-.07))+
    0.121;


    //// your implementation ends
}

float sdfTeapot(vec3 p, vec3 o, vec3 r)
{
    p -= o;
    p = rotate(p, vec3(1., 0., 0.), r.x);
    p = rotate(p, vec3(0., 1., 0.), r.y);
    p = rotate(p, vec3(0., 0., 1.), r.z);

    // sdf is undefined outside the unit sphere, uncomment to witness the abominations
    if(length(p) > 1.)
    {
        return length(p) - 0.9;
    }

    //// your implementation starts

    vec4 f0_0=sin(p.y*vec4(-4.26,-2.40,3.72,-3.55)+p.z*vec4(1.22,-3.93,-.11,.37)+p.x*vec4(-1.82,4.01,-2.51,1.63)+vec4(-6.47,-5.37,-1.26,5.56));
    vec4 f0_1=sin(p.y*vec4(-3.04,-2.33,-3.90,-.31)+p.z*vec4(-2.67,2.20,1.73,3.97)+p.x*vec4(-.88,2.18,-.82,-2.59)+vec4(-2.99,.02,-2.43,-1.59));
    vec4 f0_2=sin(p.y*vec4(1.20,3.49,3.17,-4.28)+p.z*vec4(-3.38,2.63,2.23,2.51)+p.x*vec4(1.30,.86,-2.48,-4.22)+vec4(-2.75,-3.92,-6.66,-7.60));
    vec4 f0_3=sin(p.y*vec4(-.76,1.07,2.04,-2.31)+p.z*vec4(2.89,1.87,1.82,-.12)+p.x*vec4(1.78,-2.92,3.50,-1.53)+vec4(5.02,7.68,-6.63,.43));
    vec4 f1_0=sin(mat4(-.38,-.56,.23,.39,.29,-.77,.05,.12,.06,.58,-.35,.60,.23,-.08,.00,.77)*f0_0+
    mat4(.16,-.25,.65,.39,-.20,.02,.14,-.30,.45,-.11,.03,.24,.13,.20,.33,-.56)*f0_1+
    mat4(.18,-.46,.09,.52,-.26,.04,1.34,.26,.22,-.19,-.07,.37,-.19,-.11,-.04,-.01)*f0_2+
    mat4(.66,-.03,-.82,.12,-.26,-.14,.42,-.42,.26,.05,-.42,.29,.91,-.16,-.07,.58)*f0_3+
    vec4(.14,.20,-2.35,-2.18))/1.0+f0_0;
    vec4 f1_1=sin(mat4(-.33,-.31,-.10,-.46,-.03,-.42,.04,-.62,-.23,.20,-.56,.36,.29,-.19,.35,.25)*f0_0+
    mat4(-.03,.40,-.47,.02,.59,.08,-.46,.44,-.51,.49,.10,.36,-.23,.40,.34,.24)*f0_1+
    mat4(-.68,.14,-.65,-.53,-.09,-.51,.27,.15,-.31,-.11,-.15,-.10,.08,.10,-.24,-.19)*f0_2+
    mat4(.15,.14,-.23,-.32,.17,-.36,-.18,.74,.11,-.08,-.44,.73,.31,.89,.60,.17)*f0_3+
    vec4(-2.25,-2.10,2.36,-2.46))/1.0+f0_1;
    vec4 f1_2=sin(mat4(-.09,-.34,-.09,-.13,-.08,-.05,-.24,.24,.30,-.86,.56,-.34,-.26,-.34,.42,.36)*f0_0+
    mat4(.04,-.20,-.53,-.09,-.62,.30,.02,-.32,.49,-.70,-.12,.11,.25,-.91,-.55,.07)*f0_1+
    mat4(-1.31,.12,.19,-.07,.30,-.30,-.32,-.19,-.01,.33,-.23,.42,-.31,-.25,-.07,.15)*f0_2+
    mat4(-.27,-.53,-.21,.78,-.06,-.14,.14,-.17,.13,-.29,.17,-.26,-.32,-.20,.47,.62)*f0_3+
    vec4(-.08,-2.27,-1.81,3.48))/1.0+f0_2;
    vec4 f1_3=sin(mat4(.49,-.35,.32,-.54,-.01,-.43,.20,.21,.71,-.09,-.03,.03,-.10,-.02,.18,-.73)*f0_0+
    mat4(.32,-.22,.24,-.07,-.10,.40,.46,-.05,.13,-.04,.40,-.13,.23,-.30,-.23,-.27)*f0_1+
    mat4(.79,-.12,.73,-.20,.32,.09,.14,-.07,-.70,.05,-.04,-.07,-.39,-.30,-.17,-.22)*f0_2+
    mat4(-.03,-.86,.09,-.06,-.03,-.15,.37,.30,.35,.42,-.16,-.14,.87,.45,.24,.16)*f0_3+
    vec4(3.33,-.30,1.40,-1.49))/1.0+f0_3;
    vec4 f2_0=sin(mat4(-.81,.82,.32,-.73,-.04,-.04,-.15,.06,.19,.03,-.44,.24,-.47,-.11,-.92,.63)*f1_0+
    mat4(.39,-.17,-.56,.21,.45,.43,.23,-.12,.45,-.12,.12,-.18,-.13,-.56,-.30,.24)*f1_1+
    mat4(.04,.24,-.44,-1.36,.08,-.06,.24,.25,-.44,-.54,-.18,-.45,-.68,-.30,-.73,-.14)*f1_2+
    mat4(.80,.18,.27,-.65,-.40,-.45,.76,-.55,.51,.09,.14,-.65,.10,-.23,-1.11,.04)*f1_3+
    vec4(-.41,3.52,3.31,-2.94))/1.4+f1_0;
    vec4 f2_1=sin(mat4(-.78,-.09,-.38,-.27,.08,-.53,-.12,.46,.90,-.25,.57,.15,.39,.47,.50,.14)*f1_0+
    mat4(.10,-.14,.61,.31,.72,-.22,.74,-.19,.07,-.86,.18,.51,-.23,-.26,-.19,-.14)*f1_1+
    mat4(-.28,.29,.06,.06,-.45,.72,.19,.33,.37,-.10,.29,.31,.33,-.05,.05,.36)*f1_2+
    mat4(.00,.10,-.75,-.29,.26,-.25,-.61,-.51,-.50,-.44,.05,-.34,.50,-.14,-.27,-.37)*f1_3+
    vec4(2.73,.11,3.50,1.57))/1.4+f1_1;
    vec4 f2_2=sin(mat4(-.11,.22,-.02,-.22,-.39,.32,-.06,-.29,-.13,.41,-.29,.24,-.25,-.34,.08,.64)*f1_0+
    mat4(.33,-.85,-.35,.54,.24,-.06,.15,.89,-.36,-.58,-.16,-.15,-.04,.19,.52,.32)*f1_1+
    mat4(.10,-.43,-.41,-.00,.10,-.22,.45,-.28,-.58,.04,.05,.20,.52,-.24,.13,.27)*f1_2+
    mat4(.07,-.02,.16,-.22,.26,-.07,-.39,.48,.50,-.94,.17,.06,-.18,-.37,.39,.69)*f1_3+
    vec4(-1.50,.23,-1.75,1.06))/1.4+f1_2;
    vec4 f2_3=sin(mat4(-.33,-.49,-.44,.10,-.33,.23,.05,.15,-.13,.63,.24,.43,-.53,.46,.65,-.06)*f1_0+
    mat4(.43,.63,.28,-.07,.63,-.04,-.40,.27,-.44,-.97,-.24,.08,.15,-.34,-.16,.14)*f1_1+
    mat4(-.42,.44,-.40,.74,.25,.17,.48,-.45,.11,.47,.06,-.10,.12,.32,.18,-.13)*f1_2+
    mat4(-.20,.43,-.06,.61,-.25,-.48,-.56,-.35,-.20,-.21,-.10,.02,.28,.50,.45,.21)*f1_3+
    vec4(-1.13,-.07,-2.11,-2.19))/1.4+f1_3;
    vec4 f3_0=sin(mat4(.85,.67,.63,.06,-.67,.58,-.48,-.35,-.02,-.29,-.04,-.25,.39,.34,-1.22,-.34)*f2_0+
    mat4(.71,-.37,-.92,1.37,-.90,-.79,-.26,-.06,-.20,.22,-.21,.96,-.32,.34,-.14,-.55)*f2_1+
    mat4(-.14,-.09,.79,-.09,-.06,.13,.69,.89,-.12,-.66,.27,-.20,-.21,-.15,1.28,-1.24)*f2_2+
    mat4(.18,.06,.68,.54,-.45,.30,.07,-.45,-.49,-.04,.14,-.38,.87,-.25,-.32,.45)*f2_3+
    vec4(-1.11,-2.14,3.66,-1.13))/1.7+f2_0;
    vec4 f3_1=sin(mat4(-.40,-.14,-.16,-.11,.09,.77,.13,.53,-.47,.83,-1.02,-.02,.03,.45,-.24,.52)*f2_0+
    mat4(.38,-.03,.27,1.01,.58,-.13,-.17,.43,-.28,-.53,.43,-.34,.32,.13,-.68,-.27)*f2_1+
    mat4(-.80,-.22,-.50,-.20,-.16,-.06,.56,.63,.23,-.11,-.84,-.47,-.43,-.36,.13,-.10)*f2_2+
    mat4(-.06,-.36,-.17,-.13,-.59,-1.10,-.13,-.52,.38,-.54,.14,.31,-.73,-.18,-.10,.03)*f2_3+
    vec4(-3.35,1.36,.15,1.07))/1.7+f2_1;
    vec4 f3_2=sin(mat4(-.70,-.33,-.21,.37,-.39,-.44,.49,.68,-.16,1.29,-.08,-.25,-.62,-.12,.36,.12)*f2_0+
    mat4(.61,.03,.58,-.29,.96,-.22,-.01,-.44,.63,-.67,.24,.20,.33,-.49,.08,-.09)*f2_1+
    mat4(-.48,-.35,.07,.07,.05,.74,-.28,-.13,.52,-.35,.19,.16,-.90,.27,.48,-.27)*f2_2+
    mat4(-.23,.01,.37,.34,.40,-.12,.31,.12,.59,.08,-.60,-.34,.19,-.64,.76,-.97)*f2_3+
    vec4(2.12,-2.78,.26,-3.32))/1.7+f2_2;
    vec4 f3_3=sin(mat4(.72,-.29,-.35,.68,-.51,.37,-.02,-.29,.18,-.73,1.04,.59,.57,1.03,.67,1.06)*f2_0+
    mat4(.53,.56,-.26,.13,.54,-.41,.50,-.64,.34,-.10,-.65,-.52,.22,.31,.62,.82)*f2_1+
    mat4(-.79,.26,.23,-.31,.04,-.24,-.91,-.53,-.03,-.15,.31,.14,.38,-.81,.23,.55)*f2_2+
    mat4(.54,-.13,.10,-.44,.21,-.27,-.28,1.06,.17,-.12,-.29,-.64,-.52,-.55,-.95,.40)*f2_3+
    vec4(-2.98,-.45,-.42,-3.49))/1.7+f2_3;
    return dot(f3_0,vec4(.04,-.07,.02,.02))+
    dot(f3_1,vec4(-.07,-.04,.06,.07))+
    dot(f3_2,vec4(-.07,.02,-.05,-.05))+
    dot(f3_3,vec4(-.04,-.04,.06,-.09))+
    -0.107;

    //// your implementation ends
}

float sdfUnion(float d1, float d2)
{
    return min(d1, d2);
}

/////////////////////////////////////////////////////
//// Step 3: scene sdf
//// You are asked to use the sdf boolean operations to draw the bunny and the cow in the scene.
//// The bunny is located in the ceter of vec3(-1.0, 1., 4.), and the cow is located in the center of vec3(1.0, 1., 4.).
/////////////////////////////////////////////////////

//// sdf: p - query point
float sdf(vec3 p)
{
    float s = 0.;

    float plane_h = -0.1;

    //// calculate the sdf based on all objects in the scene

    //// your implementation starts

#ifdef USE_CUSTOM_MODEL

    float plane = sdfPlane(p, plane_h);
    float rotation = iTime * ROTATION_SPEED;

    float teapot0 = sdfTeapot(p, vec3(-1.0, 1.0, 4), vec3(PI * 0.5, 0.0, rotation));
    float teapot1 = sdfTeapot(p, vec3(1.0, 1.0, 4), vec3(rotation, 0.0, 0.0));

    s = sdfUnion(plane,
    sdfUnion(teapot0, teapot1
    ));

#else

    float plane = sdfPlane(p, plane_h);
    float bunny = sdfBunny(p, vec3(-1.0, 1.0, 4));
    float cow = sdfCow(p, vec3(1.0, 1.0, 4));

    s = sdfUnion(plane,
    sdfUnion(cow, bunny
    ));

#endif

    //// your implementation ends

    return s;
}

/////////////////////////////////////////////////////
//// ray marching
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 4: ray marching
//// You are asked to implement the ray marching algorithm within the following for-loop.
//// You are allowed to reuse your previous implementation in A1a for this function.
/////////////////////////////////////////////////////

//// ray marching: origin - ray origin; dir - ray direction 
float rayMarching(vec3 origin, vec3 dir)
{
    float s = 0.0;

    //// your implementation starts

    for(int i = 0; i < MAX_RAYMARCHING_ITER; i++)
    {

        vec3 p = origin + dir * s;
        float sdf_value = sdf(p);
        if (sdf_value <= MIN_RAYMARCHING_DISTANCE) {
            return s;
        }

        s += sdf_value;

    }

    //// your implementation ends

    return s;
}

/////////////////////////////////////////////////////
//// normal calculation
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 5: normal calculation
//// You are asked to calculate the sdf normal based on finite difference.
//// You are allowed to reuse your previous implementation in A1a for this function.
/////////////////////////////////////////////////////

//// normal: p - query point
vec3 normal(vec3 p)
{
    float s = sdf(p);          //// sdf value in p
    float dx = 0.01;           //// step size for finite difference

    //// your implementation starts

    float dfdx = (sdf(p + vec3(dx, 0, 0)) - s) / dx;
    float dfdy = (sdf(p + vec3(0, dx, 0)) - s) / dx;
    float dfdz = (sdf(p + vec3(0, 0, dx)) - s) / dx;

    vec3 n = normalize(vec3(dfdx, dfdy, dfdz));

    //// your implementation ends

    return n;
}

/////////////////////////////////////////////////////
//// Phong shading
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 6: lighting and coloring
//// You are asked to specify the color for the two neural SDF objects in the scene.
//// Each object must have a separate color without mixing.
//// Notice that we have implemented the default Phong shading model for you.
/////////////////////////////////////////////////////

// From https://www.shadertoy.com/view/MsS3Wc
vec3 hsv2rgb(vec3 c )
{
    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );

    rgb = rgb*rgb*(3.0-2.0*rgb);

    return c.z * mix( vec3(1.0), rgb, c.y);
}

vec3 phong_shading(vec3 p)
{
    //// background
    if(p.z > 20.0)
    {
        return BACKGROUD_COLOR;
    }

    vec3 n = normal(p);

    //// phong shading
    vec3 lightPos = vec3(4. * sin(iTime), 4., 4. * cos(iTime));
    vec3 l = normalize(lightPos - p);
    float amb = 0.1;
    float dif = max(dot(n, l), 0.) * 0.7;
    vec3 eye = CAM_POS;
    float spec = pow(max(dot(reflect(-l, n), normalize(eye - p)), 0.0), 128.0) * 0.9;

    vec3 sunDir = normalize(vec3(0, 1, -1)); //// parallel light direction
    float sunDif = max(dot(n, sunDir), 0.) * 0.2;

    //// shadow
    float s = rayMarching(p + n * 0.06, l); // Fix Self Shadowing
    if(s < length(lightPos - p))
        dif *= .2;

    vec3 color = vec3(1.0);

    //// your implementation starts

#ifdef USE_CUSTOM_MODEL

    if(p.y < 0.0)
    {
        color = vec3(0.4, 0.4, 0.4);
    }
    else
    {
        vec3 q;

        q = p.x < 0.0 ? p - vec3(-1.0, 0.0, 0.0):p - vec3(1.0, 0.0, 0.0);

        float max_radius = 2.0;
        float angle = atan(q.y, q.x) + PI + iTime;
        float radius = length(q.xy);
        float colorh = fract(angle * 0.5 / PI);
        float colors = min(1.0, radius / max_radius);
        color = hsv2rgb(vec3(colorh, colors, 1.0));
    }


#else

    if (p.y <= 0.0) {
        color = vec3(0.9, 0.9, 0.7);
    }
    else if (p.x <= 0.0) {
        color = vec3(1., 0.4, 0.4);
    }
    else{
        color = vec3(0, 1., 1.);
    }

#endif
    
    //// your implementation ends

    return (amb + dif + spec + sunDif) * color;
}

/////////////////////////////////////////////////////
//// main function
/////////////////////////////////////////////////////

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;         //// screen uv
    vec3 origin = CAM_POS;                                                  //// camera position 
    vec3 dir = normalize(vec3(uv.x, uv.y, 1));                              //// camera direction
    float s = rayMarching(origin, dir);                                     //// ray marching
    vec3 p = origin + dir * s;                                              //// ray-sdf intersection
    // Move normal calc inside phong_shading for speed up
    vec3 color = phong_shading(p);                                       //// phong shading
    fragColor = vec4(color, 1.);                                            //// fragment color
}

void main()
{
    mainImage(gl_FragColor, gl_FragCoord.xy);
}